# Computer-Graphics-and-Visualization

Since I was creating multiple basic shapes whose vertices and indices were hard coded manually, I used a custom "BasicShape" class to create multiple instances of every object I needed. This made it modular and reusable. The class used a CreateShape() method which required the vertices and the indices as vectors, as well as OpenGL's transform matrix and its shader memory location. Each instance kept track of its own position, rotation, and scale and had the ability to update OpenGL's transform later on when the BasicShape's draw() function was called. It made sense to me to give the BasicShape class the responsibility of knowing what its own transform data was. I allowed the class to keep OpenGL's transform memory location since this program only used 1 shader for its objects (there was another shader used purely for visualizing lights as a solid object, but you could give it the light shader on the light's initialization). This gives the OpenGL caller the flexibility to specify which shader should be used for a particular object. I could have included a method to change the shader the object used, but it was not necessary for such a small program. As an afterthought, the Light class was nearly identical to the BasicShape class, but had additional functionality, so I should have had the Light class inherit from the BasicShape class. 

Any code that needed to be repeated was placed within a function. I also kept code that didn't need to repeat within OpenGL's Initialize() function and any code that needed to be updated each frame within OpenGL's run() function or within the BasicShape's methods that could be called automatically. For example, BasicShape would need to update OpenGL's active VAO and its data, so the code was placed within BasicShape's draw() method. 

Code needed to be refactored throughout the project. Most often, it was to expand functionality or flexibility. When I ran into issues, I checked the error logs, used breakpoints to step through the program, and pondered why an issue might be occurring based on what I know is happening in the background for possible causes. 

These computation and graphic concepts are extremely important to my professional goals because I want to become a game developer. Though most games are likely not controlled at such a low level, the understanding of what is happening in the background will be very helpful at becoming intuitive when making games and assist in any troubleshooting processes. Personally, I would love to be a part a game development team that creates their own game engine as I prefer to write code rather than use code blocks or GUIs (though I cannot deny their efficiency).
